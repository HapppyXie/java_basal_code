System.err.println用于显示错误信息


当多个线程同时并发执行时，虽然各个线程中语句的执行顺序是确定的，但线程的相对执行顺序是不确定的。
	有些情况下，这种因多线程并发执行而引起的执行顺序的不确定性是无害的，不影响程序运行的结果。
	但有些情况下，如多线程对共享资源操作时，这种线程运行顺序的不确定性会导致执行结果的不确定性。
	因此需要一种机制对共享数据的操作进行并发控制，保证共享数据的一致性。

对象锁及其操作：	
 （1）一个程序中的各个并发线程中对同一个对象（共享数据）进行访问的代码段，称为临界区-可以是一个语句块或方法
 （2）临界区通过对象锁控制，Java平台将每个由synchronized(someObject){}指定的对象someObject
 	 设置一个锁，称为对象锁。
 （3）对象锁是一种排他锁（exclusive locks），含义：当一个线程获得对象的锁后，便拥有该对象的操作权，
 	 其他任何线程不能对该对象进行任何操作。
 （4）线程在进入临界区时，首先通过synchronized(someObject)语句测试并获得对象的锁，只有获得对象锁
 	 才能继续执行临界区中的代码，否则进入等待状态。
 	 ？如何测试
 	 
线程锁：锁什么都可以，锁什么看传来的参数，属性就锁属性，对象就锁对象

对象锁使用说明：
 （1）关于对象锁的返还：synchronized()语句块执行完;
 				  synchronized()语句块中出现异常;
 				  持有锁的线程调用该对象的wait()方法。此时该对象将释放对象的锁，而被放入wait pool
 				  	中等待某种事情的发生
 （2）共享数据的所有访问都必须作为临界区，使用synchronized进行加锁控制
 （3）synchronized保护的共享数据必须是私有的
 （4）如果一个方法的整个方法都包含在synchronized语句块中，则可以把该关键字放在方法的声明中,
 	 控制对象锁的时间较长，效率受到一定影响，但影响不大

 （5）Java中对象锁具有可重入性。持有某个对象的情况下，可以再次请求并获得该对象的锁。避免单个线程因为
 	 线程自己已经持有的锁而产生死锁。
对象锁：锁对象    	对象.method(); method被synchronized修饰，对象的锁被线程获取
	 
main-主线程:main执行后，按顺序执行，子线程启动start()后，主线程与各个子线程一同被调度，
		  没有new Thread()之前为主线程，因为还未创建子线程
 
	
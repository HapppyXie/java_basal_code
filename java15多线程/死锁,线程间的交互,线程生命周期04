死锁：程序中多个线程相互等待对方持有的锁，而在得到对方持有的锁之前不会释放自己的锁，由此导致这些线程不能运行。
	Java没有专门检测和避免死锁的专门机制。如果程序访问多个共享资源，则要首先从全局考虑定义一个获得锁的顺序，
并且在整个程序中都要遵守这个顺序。释放锁时，要按加锁的反序释放。

解决，线程间的交互：
Java.lang.Object类的两个方法：wait(),notify():
	如果某个线程（执行流）调用了x.wait()，该线程将放入x的wait pool并且释放x的锁；
	当线程调用x.notify()时，则将会使x的wait pool中的中的一个线程移入lock pool中等待x的锁，
	一旦获得便可执行。
	notifyAll()唤醒全部，x.notifyAll()把x对象的wait pool中的所有线程移入lock pool中。

wait(),notify()前须有synchronized才可调用,需拿到对象锁
	
	
	
	
	
不同的线程，线程体不同；相同的线程，线程体相同

线程生命周期：
 （1）新建状态(new)： Thread myThread = new Thread();
 	 新建状态的线程没有被分配相关的系统资源，只能使用start()和stop()
 	 
 （2）可运行状态(Runnable)：	调用start()方法后，系统为线程分配必要的资源，
 	 将线程中的模拟cpu置为Runnable状态。线程可运行但不一定在运行中，多个线程同时处于Runnable状态，
 	 它们竞争有限的cpu资源，由系统根据线程调度策略进行调度。
 	 
 （3）运行状态(Running)：线程占有cpu并实际运行的状态。
   	 线程正常执行结束或应用程序终止运行，线程进入终止状态
   	 调用yield()方法或出现高级别的线程进入可运行状态，当前线程的cpu资源被抢占；或在分时执行时，当前执行
   	  （当前线程执行完当前时间片）由系统控制进入可运行状态。
   	 
  （4）阻塞状态(Blocked)：
  		调用sleep(),join()进入其他阻塞状态
  		调用wait()进入等待阻塞状态；notify(),notifyAll(),interrupt()进入对象锁阻塞状态
  		使用synchronized来请求对象的锁但未获得，进入对象锁阻塞状态，获得锁后，进入可运行状态。
  		如果线程中有输入/输出操作，也将进入阻塞状态，待输入/输出操作结束后，线程进入可运行状态。
  （5）终止状态(Dead)：线程执行结束的状态
 
 									sleep()时间到
							 <----------------------------其他阻塞
  	  				   		 |						 		|sleep(),join()
  	   new					 |			scheduler()->		|
  	[新建状态] ---start()---[可运行状态]--------获得cpu使用权--->[运行状态]---run()执行结束->[终止状态]
  							 |		    <-yield()			|	 	|		
  							 |获得锁				synchronized|		|wait()
						  	<---------------------对象锁阻塞<--------等待阻塞
															interrupt()
															notify()
															notifyAll()
															
															
															
															
															
															
															
															
															
															